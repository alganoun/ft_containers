#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <random>
#include "srcs/map.hpp"
#include "srcs/stack.hpp"
#include "srcs/utils/tree_iterator.hpp"
#include "srcs/vector.hpp"

// using std::vector;
// using std::string;
// using std::cout;

template <typename T, typename Key, typename Compare = std::less<Key> >
class BinTree {

	// ft::map<Key, T, Compare> &map;
	// ft::_node<int> _root;
	// typename ft::tree<Key, T, Compare>::node_pointer _root;
	// typename ft::tree<Key, T, Compare>::pair pair;
	ft::_node<ft::pair<const Key, T> > *_root;

public:
	BinTree() : _root(nullptr) {}
	BinTree(ft::_node<ft::pair<const Key, T> > *_root) : _root(_root) {}
	//~BinTree() { delete tree->_root; }

	int get_max_depth() const { return _root ? _root->max_depth() : 0; }
	// void clear() { delete map.get_tree()._root; map.get_tree()._root = nullptr; }
	void insert() {}
	/*template <typename ...Args>
	void insert(const T& value, Args...more) {
		if(!map.get_tree()._root) {
			map.get_tree()._root = new ft::pair<Key, T>(value);
		} else {
			ft::pair<Key, T>* p = map.get_tree()._root;
			for(;;) {
				if(value == p->data) return;
				ft::pair<Key, T>* &pchild = value < p->data ? p->left : p->right;
				if(!pchild) {
					pchild = new ft::pair<Key, T>(value);
					break;
				}
				p = pchild;
			}
		}
		insert(more...);
	}*/

	struct cell_display {
		std::string   valstr;
		bool     present;
		cell_display() : present(false) {}
		cell_display(std::string valstr) : valstr(valstr), present(true) {}
	};

	using display_rows = std::vector< std::vector< cell_display > >;

	// The text map.get_tree() generation code below is all iterative, to avoid stack faults.

	// get_row_display builds a std::vector of vectors of cell_display structs
	// each std::vector of cell_display structs represents one row, starting at the map.get_tree()._root
	display_rows get_row_display() const {
		// start off by traversing the map.get_tree() to
		// build a std::vector of vectors of ft::pair<Key, T> pointers
		std::vector<ft::_node<ft::pair<const Key, T>>*> traversal_stack;
		std::vector< std::vector<ft::_node<ft::pair<const Key, T> >* > > rows;
		if(!_root) return display_rows();

		ft::_node<ft::pair<const Key, T>> *p = _root;
		const int max_depth = _root->max_depth();
		rows.resize(max_depth);
		int depth = 0;
		for(;;) {
			// Max-depth Nodes are always a leaf or null
			// This special case blocks deeper traversal
			if(depth == max_depth-1) {
				rows[depth].push_back(p);
				if(depth == 0) break;
				--depth;
				continue;
			}

			// First visit to node?  Go to left child.
			if(traversal_stack.size() == depth) {
				rows[depth].push_back(p);
				traversal_stack.push_back(p);
				if(p) p = p->left;
				++depth;
				continue;
			}

			// Odd child count? Go to right child.
			if(rows[depth+1].size() % 2) {
				p = traversal_stack.back();
				// _node_prev(Node node);
				if(p) p = p->right;
				++depth;
				continue;
			}

			// Time to leave if we get here

			// Exit loop if this is the tree->_root
			if(depth == 0) break;

			traversal_stack.pop_back();
			p = traversal_stack.back();
			--depth;
		}

		// Use rows of ft::pair<Key, T> pointers to populate rows of cell_display structs.
		// All possible slots in the tree get a cell_display struct,
		// so if there is no actual ft::pair<Key, T> at a struct's location,
		// its boolean "present" field is set to false.
		// The struct also contains a string representation of
		// its ft::pair<Key, T>'s value, created using a std::stringstream object.
		display_rows rows_disp;
		std::stringstream ss;
		for(const auto& row : rows) {
			rows_disp.emplace_back();
			for(ft::_node<ft::pair<const Key, T>>* pn : row) {
				if(pn) {
					ss << pn->data;
					rows_disp.back().push_back(cell_display(ss.str()));
					ss = std::stringstream();
				} else {
					rows_disp.back().push_back(cell_display());
		}   }   }
		return rows_disp;
	}

	// row_formatter takes the std::vector of rows of cell_display structs
	// generated by get_row_display and formats it into a test representation
	// as a std::vector of strings
	std::vector<std::string> row_formatter(const display_rows& rows_disp) const {
		using s_t = std::string::size_type;

		// First find the maximum value string length and put it in cell_width
		s_t cell_width = 0;
		for(const auto& row_disp : rows_disp) {
			for(const auto& cd : row_disp) {
				if(cd.present && cd.valstr.length() > cell_width) {
					cell_width = cd.valstr.length();
		}   }   }

		// make sure the cell_width is an odd number
		if(cell_width % 2 == 0) ++cell_width;

		// allows leaf nodes to be connected when they are
		// all with size of a single character
		if(cell_width < 3) cell_width = 3;


		// formatted_rows will hold the results
		std::vector<std::string> formatted_rows;

		// some of these counting variables are related,
		// so its should be possible to eliminate some of them.
		s_t row_count = rows_disp.size();

		// this row's element count, a power of two
		s_t row_elem_count = 1 << (row_count-1);

		// left_pad holds the number of space charactes at the beginning of the bottom row
		s_t left_pad = 0;

		// Work from the level of maximum depth, up to the tree->_root
		// ("formatted_rows" will need to be reversed when done)
		for(s_t r=0; r<row_count; ++r) {
			const auto& cd_row = rows_disp[row_count-r-1]; // r reverse-indexes the row
			// "space" will be the number of rows of slashes needed to get
			// from this row to the next.  It is also used to determine other
			// text offsets.
			s_t space = (s_t(1) << r) * (cell_width + 1) / 2 - 1;
			// "row" holds the line of text currently being assembled
			std::string row;
			// iterate over each element in this row
			for(s_t c=0; c<row_elem_count; ++c) {
				// add padding, more when this is not the leftmost element
				row += std::string(c ? left_pad*2+1 : left_pad, ' ');
				if(cd_row[c].present) {
					// This position corresponds to an existing ft::pair<Key, T>
					const std::string& valstr = cd_row[c].valstr;
					// Try to pad the left and right sides of the value std::string
					// with the same number of spaces.  If padding requires an
					// odd number of spaces, right-sided children get the longer
					// padding on the right side, while left-sided children
					// get it on the left side.
					s_t long_padding = cell_width - valstr.length();
					s_t short_padding = long_padding / 2;
					long_padding -= short_padding;
					row += std::string(c%2 ? short_padding : long_padding, ' ');
					row += valstr;
					row += std::string(c%2 ? long_padding : short_padding, ' ');
				} else {
					// This position is empty, Nodeless...
					row += std::string(cell_width, ' ');
				}
			}
			// A row of spaced-apart value strings is ready, add it to the result std::vector
			formatted_rows.push_back(row);

			// The tree->_root has been added, so this loop is finsished
			if(row_elem_count == 1) break;

			// Add rows of forward- and back- slash characters, spaced apart
			// to "connect" two rows' ft::pair<Key, T> value strings.
			// The "space" variable counts the number of rows needed here.
			s_t left_space  = space + 1;
			s_t right_space = space - 1;
			for(s_t sr=0; sr<space; ++sr) {
				std::string row;
				for(s_t c=0; c<row_elem_count; ++c) {
					if(c % 2 == 0) {
						row += std::string(c ? left_space*2 + 1 : left_space, ' ');
						row += cd_row[c].present ? '/' : ' ';
						row += std::string(right_space + 1, ' ');
					} else {
						row += std::string(right_space, ' ');
						row += cd_row[c].present ? '\\' : ' ';
					}
				}
				formatted_rows.push_back(row);
				++left_space;
				--right_space;
			}
			left_pad += space + 1;
			row_elem_count /= 2;
		}

		// Reverse the result, placing the tree->_root node at the beginning (top)
		std::reverse(formatted_rows.begin(), formatted_rows.end());

		return formatted_rows;
	}

	// Trims an equal number of space characters from
	// the beginning of each std::string in the std::vector.
	// At least one std::string in the std::vector will end up beginning
	// with no space characters.
	static void trim_rows_left(std::vector<std::string>& rows) {
		if(!rows.size()) return;
		auto min_space = rows.front().length();
		for(const auto& row : rows) {
			auto i = row.find_first_not_of(' ');
			if(i==std::string::npos) i = row.length();
			if(i == 0) return;
			if(i < min_space) min_space = i;
		}
		for(auto& row : rows) {
			row.erase(0, min_space);
	}   }

	// Dumps a representation of the tree to std::cout
	void Dump() const {
		const int d = get_max_depth();

		// If this tree is empty, tell someone
		if(d == 0) {
			std::cout << " <empty tree>\n";
			return;
		}

		// This tree is not empty, so get a list of node values...
		const auto rows_disp = get_row_display();
		// then format these into a text representation...
		auto formatted_rows = row_formatter(rows_disp);
		// then trim excess space characters from the left sides of the text...
		trim_rows_left(formatted_rows);
		// then dump the text to std::cout.
		for(const auto& row : formatted_rows) {
			std::cout << ' ' << row << '\n';
		}
	}
};




int main() {
	ft::map<char, int> map;

	map.insert(ft::pair<char,int>('a', 30));
	map.insert(ft::pair<char,int>('c', 70));
	map.insert(ft::pair<char,int>('b', 20));
	map.insert(ft::pair<char,int>('d', 10));
	map.insert(ft::pair<char,int>('e', 50));
	map.insert(ft::pair<char,int>('0', 101));
	map.insert(ft::pair<char,int>('f', 40));
	map.insert(ft::pair<char,int>('g', 60));
	map.insert(ft::pair<char,int>('2', 100));
	// map.insert(ft::pair<char,int>('W', 30));
	// map.insert(ft::pair<char,int>('P', 70));
	// map.insert(ft::pair<char,int>('G', 20));
	// map.insert(ft::pair<char,int>('E', 20));
	// map.insert(ft::pair<char,int>('S', 20));
	// map.insert(ft::pair<char,int>('+', 9));
	// map.insert(ft::pair<char,int>('N', 20));

	// map.insert(ft::pair<char,int>('A', 30));
	// map.insert(ft::pair<char,int>('c', 70));

	BinTree<int, char> bt(map.get_tree());

	// Build OP's tree
	//bt.insert(8,5,2,6,10,9,11);
	std::cout << "Tree from OP:\n\n";
	bt.Dump();
	std::cout << "\n\n";

	//bt.clear();

	// Build a random tree
	// This toy tree can't balance, so random
	// trees often look more like linked lists.
	// Just keep trying until a nice one shows up.
	/*std::random_device rd;
	std::mt19937 rng(rd());

	int MaxCount=20;
	int MaxDepth=5;
	const int Min=0, Max=1000;

	std::uniform_int_distribution<int> dist(Min,Max);

	while(MaxCount--) {
		// bt.insert(dist(rng));
		// bt.insert(dist(rng));
		if(bt.get_max_depth() >= MaxDepth) break;
	}*/
}
